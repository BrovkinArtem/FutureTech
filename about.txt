Терминал npm:
1. npm init - инициализация проекта
2. package.json - инфа о проекте и библиотеки
3. npm i sass -D  - установка sass Для проекта, в папку для разработки
4. Не смотря на то что я например не буду пользоваться scss скриптом, т.к. стоит расширение в VSCode, писать такое стоит
5. npm run sass-watch - запуск скрипта

Про html:
1. Эмит на текст рыбу - lorem100 - напишет текст белеберду на 100 слов
2. Баннеры с краткой информацией о сайте, называют hero
3. При выгрузке картинок, лучше отключать все лишние свойства в фигме
4. В ссылки (<a>) можно вкладывать практически что угодно, главное чтобы не было других интерактивных элементов (другие ссылки, кнопки и тд)
5. aria-labelledby может ссылаться на несколько элементов
6. В placeholder нужно записывать пример заполнения, а не копирование label
7. От макета отклонятся нормально, если это принесёт будущему пользователю пользу
8. placeholder="(999) 999-99-99" - для телефонов с неизвестным префиксом
9. Для того чтобы при раскрытии одного элемента в аккардионе закрывались другие, нужно просто указать у всех один name="faq" (faq - это пример)
10. Для стилизации чекбокс нужно указать у input - appearance: none;
11. Хорошей практикой будет проверять вёрстку после её окончания

Про стили:
1. Подключение стилей в main.scss - @use "normalize";
2. 1 - используем use, т.к. import - устаревший
3. В этот раз вспомогающие стили выделяем в отдельную папку - helpers
4. Через @forward "mixins"; - подключяются стили
5. _ в названии файлов - обработка не нужна (говорим препроцессору)
6. normalize всегда берём с последнего проекта (всё время дополняется)
7. у кнопок теперь норма cursor: pointer;
8. @mixin fluid-text - был дополнен, у проектов только менять макс и мин ширину экранов
9. @mixin hide и @mixin show - Для скрытия и показ элементов
10. aspect-ration не всегда работает так как ожидаем, поэтому иногда лучше указывать через width и height
11. Есть баг при медиа запросах, чтобы его избегать указывать media запрос с дробным окончанием, к примеру: 1440.98
12. Написали новый hover, который будет срабатывать на устройствах без touchScreen`а`, а на других будет active
13. Название index.scss нигде не указывается при подключение папки, sass автоматически сам всё сделает
14. У sass проблемы с функциями в переменных, поэтому оборачиваем в #{} - например - #{rem(1600 )}
15. padding для --container-padding-x всегда смотрим по мобильной версии!
16. !important - используем только для классов
17. :focus-visible {    outline: 2px в rem dashed var(--color-light);} - при взятии элемента в фокус рамка 2рем, пунктир, белый цвет
18. outline-offset: rem(4); - смещение обводки
19. Для ссылки (лого в пример) - <a href="/" class="header__logo logo" title="Home" aria-label="Home"></a> указываем title и aria-label, так мы даём подсказку куда будет вести ссылка
20. loading="lazy" - убираем, т.к. шапка всегда перед лицом пользователя при загрузке
21. Порядок стилей - 1.Переменные 2.Миксины 3.Стили 4.Медиа-запросы
22. Стили для background лучше указывать точечно, а не как в прошлых уроках в одном стиле: background-position: center; background-size: contain; background-repeat: no-repeat;
23. При названии иконок, свойства через -, цвет через _ пример - arrow-top-right_yellow
24. @include hide; translate: 100%; - смещаем за экран и делаем невидимым меню и кнопку
25. position: fixed; inset: 0; - растягивание элемента на весь экран
26. Липкая шапка - position: sticky; z-index: 100; top: 0; Благодарю набору таких стилей, шапка будет видна всегда при скроле страницы
27. Добавление тени при проскроливании страницы:
                // animation-name: scrolling-header;
                // animation-fill-mode: both;
                // animation-timeline: scroll();
                // animation-range: rem(100) rem(200);
                // 
                // @keyframes scrolling-header {
                //   to {
                //     box-shadow: 0 0 1rem 0 var(--color-dark-40);
                //   }
                // }
28. Чтобы прижать footer к низу в globals пишем - Для bode display: flex; flex-direction: column; и для main flex-grow: 1; - flex-grow: 1; Растягивает основной контент на максимум, как раз прижимая footer
29.  Для всяких приписок по типу New или стрелки желтой, мы добавляем display: inline-flex;
30. Градиент через background: linear-gradient(указываем как идти ему 45deg, и цвета перехода dark 65%, white130%) к примеру
31. у градиента можно указывать где он будет наноситься в конце за linear-gradient пишем padding-box - если фон и border-box - если рамка
32. Чтобы растянуть элемент на несколько колонок - grid-column: -1 / 1;
33. Главные заголовки секций, хорошим тоном будет связать вместе с самими секциями, к примеру у h1 будет id="hero-title", а у секции hero будет атрибут aria-labelledby="hero-title", таким образом мы помогаем скриридерам
34. dl - Список описаний (ul, ol, теперь dl), далее мы делаем div и внутри dt (description list)
35. dt - Имя в списке описаний (заголовок) (description term)
36. dd - Описание (статистика) (description definition)
37. По ходу вёрстки определенной секции, отключаем другие секции - .header, .footer {   display: none !important; }
38. С помощью grid-template-areas: "body resources-preview" "metrics resources-preview"; Мы указываем для каждой ячейки своё Название
39. И для надлежащего ячейки элемента указываем привязанность &__body { grid-area: body; }
40. Также с помощью 38 и 39 мы указываем места элементов на грид сетке
41. Отступы вниз и вправо (margin-top, margin-right) лучше всегда писать через :not(:last-child), для того чтобы разметка была более надежная
42. background-color можно указывать для img, если это png
43. Вместо display: flex; flex-direction: column; можно писать display: grid;
44. Для того чтобы скрыть все элементы main, кроме нового блока - main > *:not(:last-child), удобно для разработки
45. При создании элемента tabs (вкладки) указываем атрибут role="tablist" — это роль-обёртка для группы вкладок. С её помощью создают список элементов вкладки, которые являются ссылками на элементы панели вкладок (tabpanel).
46. Также для tabs указываем aria-labelledby и выше невидимый заголовок, для управления
47. Для кнопок табов добавляем атрибут role="tab", а также aria-controls="tabpanel-1" для будующей связки
48. Для кнопок табов добавляем атрибут aria-selected="true" для того чтобы знать выбрана вкладка или нет
49. Активной кнопке добавляем класс is-active, неактивным атрибут tabindex="-1" - для того чтобы их нельзя было перебирать tab`ом`
50. Далее создаём в части контента div`ы` и указываем им id соответствующие aria-controls id="tabpanel-1", то есть связываем кнопки и контент
51. А также указываем aria-labelledby="tab-1" итого у нас выходит двусторонее связывание
52. Контенту же указываем tabindex="0", для фокусировки с клавиатуры
53. Aria-label и titel следует также указывать если непонятно что происходит (например что происходит по нажатию на кнопку)
54. Можно писать условия внутри селекторов по типу - &-inner { &:has(.section__link) {...}}, то есть если есть какой-то элемент, то допустим сделать display grid, чтобы перестроить элемент
55. С помощью overflow-x: auto и width: max-content сделали так что элемент сохраняет свою ширину и появляется возможность его скрола
56. &:has(> *:only-child) - Выбрать только те элементы у которых 1 элемент внутри.
57. Для автоматической перестройки сетки по минимальной ширине - grid-template-columns: repeat(auto-fit, minmax(rem(358), 1fr)); 
58. inset: 0; - растягивание элемента на всю ширину родительского элемента
59. list-style-type: disc; Для точки у каждого элемента списка вначале элементов
60. Чтобы полностью убрать маркер у details - list-style: none;  &:-webkit-details-marker {   display: none; }

Про скрипты:
1. У нас есть мастер скрипт | основной - main.js
2. Подключение - <script src="./scripts/main.js" type="module" defer> </script>
3. Для обращения к конкретным элементам добавляем им data-js атрибут, классы и id, оставляем на стлиизацию
4. Названия файлов скриптов начинаем с большой буквы (т.к. пишем в нотации классов)
5. При импорте указываем относительный путь (начинается с ./) и указываем .js - import Header from "./Header.js";
6. export default - экспорт с возможностью изменения в файле где импортируем названия
7. constructor() {} - автоматически выполняет код при инициализации класса
8. В каждом конструкторе Подключаем элементы которые указывали (помним про слова this и querySelector)
9. Манипуляции по типу обращения к атрибуту, создания в классе объекта selectors, нужны для избежания волшебных строк и магических чисел (когда не понятно что делает программа и константы), чтобы не возникало странное поведение у программы
10. В каждом конструкторе есть bindEvents, в нём мы привязываем различные действия к элементам
11. Сами методы в классе пишем через стрелочную нотацию - nameFunction () => {}
12. Элемент табов делаем из 2ух классов - Tabs - основная логика конкретной группы табов, TabsCollection - инициализация логики всех табов на одной страницы
13. экспортируем TabsCollection
14. Делаем для tab`а` переключение через хоткеи и стрелки 
15. Используем объект Proxy для контроля получения и установки активного состояния для кнопок по запросу
16. В js у элементов есть метод animate, первым элементом принимает массив ключевых кадров, вторым - параметры анимации 
17. Файлы взятые с cdn, подключать строго до основного скрипта
18. imask.js - библиотека с масками для инпутов, вбей и найди документацию, для подключение cdn добавь и скопируй 1 ссылку, ставь в src
19. Число 0 означает любое число, а не только ноль
20. При подключение библотеки в коде проверяем работает ли она, для этого проверяем один из её методов const isLibReady = typeof window.IMask !== "undefined"
21. Создаём абстрактный класс для Proxy, для переиспользования
22. абстрактный класс - класс от которого наследуют другие классы
23. Имплеменирование - восоздание некоторых нужных свойсвт для класса (например из абстрактного класса)
24. От абстрактного класса можно расширяться, но нельзя создать его экземпляр
25. Защита от 24 - 
                    // if (this.constructor === BaseComponent) {
                    //    throw new Error("Не возможно создать экземпляр абстрактного класса BaseComponent!")
                    // }
26. Наследование - class Tabs extends BaseComponent
27. super() - Пишется в constructor, активация функционала класса от которого расширились
28. const mediaInfo = window.matchMedia('(window <= 767.98px)'), булевый метод для проверки соответствия размера экрана
29. метод 28, является динамичным тригером
30. MatchMedia.mobile.addEventListener() MatchMedia позволяет задать addEventListener, даже несмотря на то что matchMedia не элемент
31. document.activeElement - хранит ссылку на элемент в фокусе, он либо один, либо его нет
32. При разработки кастомных компонентов в интернете много гайдов есть как они должны выглядеть и что делать (включая управление с клавиатуры и прочее)

hotkeys:
1. alt + стрелки вверх, вниз, перемещение строки вверх или вниз
2. alt + стрелки влево вправо, перемещение по истории файлам

devtools:
1. У стилей можно нажать справа вверху .cls, тем самым можно включить или выключить какой-либо имеющийся у них класс